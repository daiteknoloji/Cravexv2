{"version":3,"file":"bundles/66f60e374fa520826807/9483.js","mappings":"qIAAA,IAAIA,EAAQ,EAAQ,kEAEpBC,EAAOC,QASP,SAAwBC,GACtB,GAAgB,MAAZA,EAAK,GAAa,MAAM,IAAIC,MAAM,4BACtC,GAAgB,KAAZD,EAAK,GAAa,MAAM,IAAIC,MAAM,4BACtC,GAAgB,KAAZD,EAAK,GAAa,MAAM,IAAIC,MAAM,4BACtC,GAAgB,KAAZD,EAAK,GAAa,MAAM,IAAIC,MAAM,4BACtC,GAAgB,KAAZD,EAAK,GAAa,MAAM,IAAIC,MAAM,iFACtC,GAAgB,KAAZD,EAAK,GAAa,MAAM,IAAIC,MAAM,iFACtC,GAAgB,KAAZD,EAAK,GAAa,MAAM,IAAIC,MAAM,4BACtC,GAAgB,KAAZD,EAAK,GAAa,MAAM,IAAIC,MAAM,iFAEtC,IAAIC,GAAQ,EACRC,EAAS,GACTC,EAAM,EAEV,KAAOA,EAAMJ,EAAKK,QAAQ,CAGxBC,EAAM,GAAKN,EAAKI,KAChBE,EAAM,GAAKN,EAAKI,KAChBE,EAAM,GAAKN,EAAKI,KAChBE,EAAM,GAAKN,EAAKI,KAGhB,IAAIC,EAASE,EAAO,GAAK,EACrBC,EAAQ,IAAIC,WAAWJ,GAC3BG,EAAM,GAAKR,EAAKI,KAChBI,EAAM,GAAKR,EAAKI,KAChBI,EAAM,GAAKR,EAAKI,KAChBI,EAAM,GAAKR,EAAKI,KAGhB,IAAIM,EACFC,OAAOC,aAAaJ,EAAM,IAC1BG,OAAOC,aAAaJ,EAAM,IAC1BG,OAAOC,aAAaJ,EAAM,IAC1BG,OAAOC,aAAaJ,EAAM,IAI5B,IAAKL,EAAOE,QAAmB,SAATK,EACpB,MAAM,IAAIT,MAAM,uBAKlB,GAAa,SAATS,EAAiB,CACnBR,GAAQ,EACRC,EAAOU,KAAK,CACVH,KAAMA,EACNV,KAAM,IAAIS,WAAW,KAGvB,KACF,CAGA,IAAK,IAAIK,EAAI,EAAGA,EAAIT,EAAQS,IAC1BN,EAAMM,GAAKd,EAAKI,KAKlBE,EAAM,GAAKN,EAAKI,KAChBE,EAAM,GAAKN,EAAKI,KAChBE,EAAM,GAAKN,EAAKI,KAChBE,EAAM,GAAKN,EAAKI,KAEhB,IAAIW,EAAYC,EAAM,GAEtB,GADgBnB,EAAMoB,IAAIT,KACRO,EAChB,MAAM,IAAId,MACR,kBAAoBS,EAAO,sDAM/B,IAAIQ,EAAY,IAAIT,WAAWD,EAAMW,OAAOC,MAAM,IAElDjB,EAAOU,KAAK,CACVH,KAAMA,EACNV,KAAMkB,GAEV,CAEA,IAAKhB,EACH,MAAM,IAAID,MAAM,yDAGlB,OAAOE,CACT,EA9FA,IAAIG,EAAQ,IAAIG,WAAW,GACvBO,EAAQ,IAAIK,WAAWf,EAAMa,QAC7BZ,EAAS,IAAIe,YAAYhB,EAAMa,O,2ECPnC,IACWI,IAgBT,SAASC,GACXA,EAAMC,QAAU,QAqBhB,IAAIC,EAnBJ,WAGC,IAFA,IAAIC,EAAI,EAAGD,EAAQ,IAAIE,MAAM,KAErBC,EAAG,EAAQ,KAALA,IAAYA,EASzBF,EAAQ,GADRA,EAAQ,GADRA,EAAQ,GADRA,EAAQ,GADRA,EAAQ,GADRA,EAAQ,GADRA,EAAQ,GADRA,EAAQ,GADRA,EAAIE,IACW,UAAaF,IAAM,EAAOA,IAAM,IAChC,UAAaA,IAAM,EAAOA,IAAM,IAChC,UAAaA,IAAM,EAAOA,IAAM,IAChC,UAAaA,IAAM,EAAOA,IAAM,IAChC,UAAaA,IAAM,EAAOA,IAAM,IAChC,UAAaA,IAAM,EAAOA,IAAM,IAChC,UAAaA,IAAM,EAAOA,IAAM,IAChC,UAAaA,IAAM,EAAOA,IAAM,EAC/CD,EAAMG,GAAKF,EAGZ,MAA6B,oBAAfN,WAA6B,IAAIA,WAAWK,GAASA,CACpE,CAEYI,GAERC,EAA+B,oBAAXC,OAwBxB,SAASC,EAAYhB,GACpB,IAAI,IAAIiB,GAAO,EAAGpB,EAAI,EAAGqB,EAAElB,EAAIZ,OAAO,EAAGS,EAAIqB,GAQ5CD,GADAA,GADAA,GADAA,GADAA,GADAA,GADAA,GADAA,EAAOA,IAAQ,EAAKR,EAAqB,KAAdQ,EAAIjB,EAAIH,UACpB,EAAKY,EAAqB,KAAdQ,EAAIjB,EAAIH,UACpB,EAAKY,EAAqB,KAAdQ,EAAIjB,EAAIH,UACpB,EAAKY,EAAqB,KAAdQ,EAAIjB,EAAIH,UACpB,EAAKY,EAAqB,KAAdQ,EAAIjB,EAAIH,UACpB,EAAKY,EAAqB,KAAdQ,EAAIjB,EAAIH,UACpB,EAAKY,EAAqB,KAAdQ,EAAIjB,EAAIH,UACpB,EAAKY,EAAqB,KAAdQ,EAAIjB,EAAIH,OAEpC,KAAMA,EAAIqB,EAAE,GAAGD,EAAOA,IAAQ,EAAKR,EAAqB,KAAdQ,EAAIjB,EAAIH,OAClD,OAAc,EAAPoB,CACR,CAyBAV,EAAME,MAAQA,EACdF,EAAMY,KA9DN,SAAoBA,GACnB,GAAGA,EAAK/B,OAAS,OAAU0B,EAAY,OAAOE,EAAY,IAAID,OAAOI,IAErE,IADA,IAAIF,GAAO,EAAGC,EAAIC,EAAK/B,OAAS,EACxBS,EAAI,EAAGA,EAAIqB,GAClBD,EAAOR,EAAqC,KAA9BQ,EAAME,EAAKC,WAAWvB,OAAiBoB,IAAQ,EAC7DA,EAAOR,EAAqC,KAA9BQ,EAAME,EAAKC,WAAWvB,OAAiBoB,IAAQ,EAG9D,OADGpB,IAAMqB,IAAGD,EAAOA,IAAQ,EAAKR,EAAmC,KAA5BQ,EAAME,EAAKC,WAAWvB,OAC/C,EAAPoB,CACR,EAsDAV,EAAMP,IApDN,SAAmBA,GAClB,GAAGA,EAAIZ,OAAS,IAAO,OAAO4B,EAAYhB,GAC1C,IAAI,IAAIiB,GAAO,EAAGpB,EAAI,EAAGqB,EAAElB,EAAIZ,OAAO,EAAGS,EAAIqB,GAI5CD,GADAA,GADAA,GADAA,EAAOA,IAAQ,EAAKR,EAAqB,KAAdQ,EAAIjB,EAAIH,UACpB,EAAKY,EAAqB,KAAdQ,EAAIjB,EAAIH,UACpB,EAAKY,EAAqB,KAAdQ,EAAIjB,EAAIH,UACpB,EAAKY,EAAqB,KAAdQ,EAAIjB,EAAIH,OAEpC,KAAMA,EAAIqB,EAAE,GAAGD,EAAOA,IAAQ,EAAKR,EAAqB,KAAdQ,EAAIjB,EAAIH,OAClD,OAAc,EAAPoB,CACR,EA2CAV,EAAMc,IAzBN,SAAmBA,GAClB,IAAI,IAAmCX,EAAGY,EAAlCL,GAAO,EAAGpB,EAAI,EAAGqB,EAAEG,EAAIjC,OAAcS,EAAIqB,IAChDR,EAAIW,EAAID,WAAWvB,MACZ,IACNoB,EAAOA,IAAQ,EAAKR,EAAkB,KAAXQ,EAAMP,IACxBA,EAAI,KAEbO,GADAA,EAAOA,IAAQ,EAAKR,EAAkC,KAA3BQ,GAAO,IAAMP,GAAG,EAAG,SAC/B,EAAKD,EAA6B,KAAtBQ,GAAO,IAAO,GAAFP,KAC9BA,GAAK,OAAUA,EAAI,OAC5BA,EAAa,IAAN,KAAFA,GAAYY,EAA0B,KAAtBD,EAAID,WAAWvB,KAIpCoB,GADAA,GADAA,GADAA,EAAOA,IAAQ,EAAKR,EAAiC,KAA1BQ,GAAO,IAAMP,GAAG,EAAG,QAC/B,EAAKD,EAAkC,KAA3BQ,GAAO,IAAMP,GAAG,EAAG,SAC/B,EAAKD,EAAwC,KAAjCQ,GAAO,IAAMK,GAAG,EAAG,GAAO,EAAFZ,QACpC,EAAKD,EAA6B,KAAtBQ,GAAO,IAAO,GAAFK,MAIvCL,GADAA,GADAA,EAAOA,IAAQ,EAAKR,EAAmC,KAA5BQ,GAAO,IAAMP,GAAG,GAAI,SAChC,EAAKD,EAAkC,KAA3BQ,GAAO,IAAMP,GAAG,EAAG,SAC/B,EAAKD,EAA6B,KAAtBQ,GAAO,IAAO,GAAFP,KAGzC,OAAc,EAAPO,CACR,CAKA,EAzGiC,oBAAtBM,kBAERjB,EAAQxB,GAWTwB,EAAgB,CAAC,E,qnBCNZ,MAAMkB,EAKFC,WAAAA,CACaC,EACAC,EACAC,EACTC,EAAW,IACpBC,EAAAA,EAAAA,GAAA,uBATgC,IAAIC,kBAAiBD,EAAAA,EAAAA,GAAA,wBAAAA,EAAAA,EAAAA,GAAA,gBAEpC,GAAC,KAGAJ,OAAAA,EAAc,KACdC,SAAAA,EAAgB,KAChBC,SAAAA,EAAyB,KAClCC,SAAAA,CACR,CAEIG,UAAAA,CAAWC,GACdC,KAAKC,SAAWF,EAASG,OACzBF,KAAKL,SAAWI,EAASI,KAC7B,CAEOC,KAAAA,GACHJ,KAAKK,gBAAgBD,OACzB,CAEA,aAAWE,GACP,OAAON,KAAKK,gBAAgBE,OAAOC,OACvC,CAEA,SAAWL,GACP,OAAOH,KAAKL,QAChB,CAEA,UAAWO,GACP,OAAOF,KAAKC,QAChB,E,gYCfW,MAAMQ,UAA4BC,EAAAA,UAAwBnB,WAAAA,IAAAoB,GAAA,SAAAA,IAAAf,EAAAA,EAAAA,GAAA,qBAC7C,KACpBI,KAAKY,MAAMC,YAAW,MACzBjB,EAAAA,EAAAA,GAAA,qBAEuB,KACpBI,KAAKY,MAAMC,YAAW,IACzB,CAEMC,MAAAA,GACH,IAAIC,EAEAC,EACJ,GAA8B,IAA1BhB,KAAKY,MAAMK,YAAmD,IAA/BjB,KAAKY,MAAMM,SAAShE,OACnD6D,GAAUI,EAAAA,EAAAA,IACN,mCACA,CACIC,OAAOzB,EAAAA,EAAAA,IAASK,KAAKY,MAAMS,gBAAgBC,kBAC3CC,gBAAgB5B,EAAAA,EAAAA,IAASK,KAAKY,MAAMM,SAAS,GAAGM,OAEpD,CACIC,EAAIC,GAAQhB,EAAAA,cAAA,cAASgB,KAG7BV,EACIN,EAAAA,cAACiB,EAAAA,EAAa,CACVC,eAAeT,EAAAA,EAAAA,IAAG,aAClBU,WAAW,EACXC,qBAAsB9B,KAAK+B,cAC3BC,OAAO,SAGZ,GAAIhC,KAAKY,MAAMK,aAAejB,KAAKY,MAAMM,SAAShE,OACrD6D,GAAUI,EAAAA,EAAAA,IACN,oCACA,CACIC,OAAOzB,EAAAA,EAAAA,IAASK,KAAKY,MAAMS,gBAAgBC,mBAE/C,CACIG,EAAIC,GAAQhB,EAAAA,cAAA,cAASgB,KAG7BV,EACIN,EAAAA,cAACiB,EAAAA,EAAa,CACVC,eAAeT,EAAAA,EAAAA,IAAG,aAClBU,WAAW,EACXC,qBAAsB9B,KAAK+B,cAC3BC,OAAO,QAGZ,CACHjB,GAAUI,EAAAA,EAAAA,IACN,yCACA,CACIC,OAAOzB,EAAAA,EAAAA,IAASK,KAAKY,MAAMS,gBAAgBC,mBAE/C,CACIG,EAAIC,GAAQhB,EAAAA,cAAA,cAASgB,KAG7B,MAAMO,EAAgBjC,KAAKY,MAAMK,WAAajB,KAAKY,MAAMM,SAAShE,OAClE8D,EACIN,EAAAA,cAACiB,EAAAA,EAAa,CACVC,eAAeT,EAAAA,EAAAA,IAAG,qCAAsC,CAAEe,MAAOD,IACjEH,qBAAsB9B,KAAKmC,cAC3BN,WAAW,EACXO,cAAcjB,EAAAA,EAAAA,IAAG,iCACjBkB,SAAUrC,KAAK+B,cACfC,OAAO,GAGnB,CAEA,OACItB,EAAAA,cAAC4B,EAAAA,EAAU,CACPC,UAAU,yBACV1B,WAAYb,KAAK+B,cACjBS,OAAOrB,EAAAA,EAAAA,IAAG,2BACVsB,UAAU,qBAEV/B,EAAAA,cAAA,OAAKgC,GAAG,qBACH3B,EAtET4B,WA0EK3B,EAGb,E,myBCrDJ,MAAM4B,EAAa,CAAC,EAAM,EAAM,GAAM,GAAM,EAAM,EAAM,GAAM,GAAM,GAE7D,MAAMC,UAA4B/F,OAClC,MAAMgG,UAA0BhG,MAC5ByC,WAAAA,CAAYwD,GACfC,QACAhD,KAAK+C,MAAQA,CACjB,EAkEJ,MAQME,EAA2B,CAAC,aAAc,cAUhDC,eAAeC,EAAiBC,EAA4B5D,EAAgB6D,GACxE,IAAIC,EAAgB,YACG,eAAnBD,EAAUE,OACVD,EAAgB,cAIpB,MAAME,GAAoBC,EAAAA,EAAAA,GAAeJ,GAEnCK,QAhFVR,eAAgCG,GAM5B,MAAMM,EAAM,IAAIC,MACVC,EAAYC,IAAIC,gBAAgBV,GAChCW,EAAa,IAAIC,QAAQ,CAACC,EAASC,KACrCR,EAAIS,OAAS,WACTN,IAAIO,gBAAgBR,GACpBK,EAAQP,EACZ,EACAA,EAAIW,QAAU,SAAUC,GACpBJ,EAAOI,EACX,IAEJZ,EAAIa,IAAMX,EAIV,IAAIY,EAAeR,QAAQC,SAAQ,GACZ,cAAnBb,EAAUE,OAMVkB,EAAeC,EADCrB,GAEXsB,KAAMC,IACH,MAAM5G,EAAS,IAAIV,WAAWsH,GACxB5H,EAAS6H,IAAiB7G,GAChC,IAAK,MAAMX,KAASL,EAChB,GAAmB,SAAfK,EAAME,KACN,OAAIF,EAAMR,KAAKiI,aAAelC,EAAW1F,QAClCG,EAAMR,KAAKkI,MAAM,CAACC,EAAKrH,IAAMqH,IAAQpC,EAAWjF,IAG/D,OAAO,IAEVsH,MAAOV,IACJW,QAAQC,MAAM,sBAAuBZ,IAC9B,KAInB,MAAOa,SAAenB,QAAQoB,IAAI,CAACZ,EAAcT,IAGjD,MAAO,CAAEsB,MAFKF,EAAQzB,EAAI2B,OAAS,EAAI3B,EAAI2B,MAE3BC,OADDH,EAAQzB,EAAI4B,QAAU,EAAI5B,EAAI4B,OACrB5B,MAC5B,CA8B+B6B,CAAiBnC,GAEtCoC,QAAeC,EAAAA,EAAAA,GAAgBhC,EAAaC,IAAKD,EAAa4B,MAAO5B,EAAa6B,OAAQjC,GAC1FqC,EAAYF,EAAOG,KAQzB,QALmBC,UADMrC,IAErBmC,EAAU,wCAA0CnC,IAInDP,EAAyB6C,SAASzC,EAAUE,MAAO,CAEpD,MAAMwC,EAAiB1C,EAAU7B,KAAOmE,EAAUK,eAAgBxE,KAClE,GAEI6B,EAAU7B,MA3CiB,OA6C1BuE,GA3C8B,OA4C3BA,GA3C8B,GA2CZ1C,EAAU7B,KAGhC,cADOmE,EAA0B,eAC1BA,CAEf,CAEA,MAAMM,QAAqBC,EAAW9C,EAAc5D,EAAQiG,EAAOU,WAInE,OAFAR,EAAyB,cAAIM,EAAaG,IAC1CT,EAA0B,eAAIM,EAAaI,KACpCV,CACX,CAwCAzC,eAAeoD,EAAiBC,GAC5B,MAAMC,QAjCV,SAA0BD,GACtB,OAAO,IAAItC,QAAQ,CAACC,EAASC,KAEzB,MAAMqC,EAAQC,SAASC,cAAc,SACrCF,EAAMG,QAAU,WAChBH,EAAMI,OAAQ,EAEd,MAAMC,EAAS,IAAIC,WAEnBD,EAAOzC,OAAS,SAAU2C,GAAU,IAAAC,EAChCR,EAAMS,iBAAmB/D,iBACrBgB,EAAQsC,EACZ,EACAA,EAAMlC,QAAU,SAAUC,GACtBJ,EAAOI,EACX,EAEAiC,EAAMhC,IAAe,QAAZwC,EAAGD,EAAGG,cAAM,IAAAF,OAAA,EAATA,EAAWvB,MAC3B,EACAoB,EAAOvC,QAAU,SAAUC,GACvBJ,EAAOI,EACX,EACAsC,EAAOM,cAAcZ,IAE7B,CASwBa,CAAiBb,GACrC,MAAO,CAAEc,SAAUC,KAAKC,KAAsB,IAAjBf,EAAMa,UACvC,CAuDA,SAASG,EAAiBpE,EAA4B5D,EAAgBiI,GAClE,MAEMC,EAAuB,CAAC,EAC9B,OAlDJ,SAA0BD,GACtB,OAAO,IAAIxD,QAAQ,CAACC,EAASC,KAEzB,MAAMwD,EAAQlB,SAASC,cAAc,SACrCiB,EAAMhB,QAAU,WAChBgB,EAAMC,aAAc,EACpBD,EAAMf,OAAQ,EAEd,MAAMC,EAAS,IAAIC,WAEnBD,EAAOzC,OAAS,SAAU2C,GAAU,IAAAc,EAAAC,EAEhCH,EAAMI,aAAe7E,iBACjBgB,EAAQyD,GACRA,EAAMK,OACV,EACAL,EAAMrD,QAAU,SAAUC,GACtBJ,EAAOI,EACX,EAEA,IAAI0D,EAAmB,QAAZJ,EAAGd,EAAGG,cAAM,IAAAW,OAAA,EAATA,EAAWpC,OAGd,QAAXqC,EAAIG,SAAO,IAAAH,GAAPA,EAASI,WAAW,2BACpBD,EAAUA,EAAQE,QAAQ,wBAAyB,oBAGvDR,EAAMnD,IAAMyD,EACZN,EAAMS,OACNT,EAAMU,MACV,EACAxB,EAAOvC,QAAU,SAAUC,GACvBJ,EAAOI,EACX,EACAsC,EAAOM,cAAcM,IAE7B,CAcWa,CAAiBb,GACnB9C,KAAMgD,IACHD,EAAUL,SAAWC,KAAKC,KAAsB,IAAjBI,EAAMN,WAC9B3B,EAAAA,EAAAA,GAAgBiC,EAAOA,EAAMY,WAAYZ,EAAMa,YANxC,gBAQjB7D,KAAMc,IACHgD,OAAOC,OAAOhB,EAAWjC,EAAOG,MACzBM,EAAW9C,EAAc5D,EAAQiG,EAAOU,aAElDxB,KAAMc,IACHiC,EAAUiB,cAAgBlD,EAAOW,IACjCsB,EAAUkB,eAAiBnD,EAAOY,KAC3BqB,GAEnB,CAQA,SAAShD,EAAsB2B,GAC3B,OAAO,IAAIpC,QAAQ,CAACC,EAASC,KACzB,MAAM0C,EAAS,IAAIC,WACnBD,EAAOzC,OAAS,SAAUG,GAAS,IAAAsE,EAC/B3E,EAAgB,QAAT2E,EAACtE,EAAE2C,cAAM,IAAA2B,OAAA,EAARA,EAAUpD,OACtB,EACAoB,EAAOvC,QAAU,SAAUC,GACvBJ,EAAOI,EACX,EACAsC,EAAOiC,kBAAkBzC,IAEjC,CAgBOnD,eAAegD,EAClB9C,EACA5D,EACA6G,EACA0C,EACAC,GAC+C,IAAAC,EAC/C,MAAM5I,EAAkB2I,QAAAA,EAAc,IAAInJ,gBAG1C,SAAkC,QAA9BoJ,EAAM7F,EAAa8F,mBAAW,IAAAD,OAAA,EAAxBA,EAA0BE,0BAA0B3J,IAAS,CAEnE,MAAM3C,QAAa6H,EAAsB2B,GACzC,GAAIhG,EAAgBE,OAAOC,QAAS,MAAM,IAAIqC,EAG9C,MAAMuG,QAAsBC,IAAAA,kBAA0BxM,GACtD,GAAIwD,EAAgBE,OAAOC,QAAS,MAAM,IAAIqC,EAG9C,MAAMyG,EAAO,IAAIC,KAAK,CAACH,EAAcvM,OAErC,IAAIuJ,EACJ,MACOoD,YAAapD,SAAchD,EAAaqG,cAAcH,EAAM,CAC3DP,kBACA1I,kBACAqJ,iBAAiB,EACjBnG,KAAM,6BAEd,CAAE,MAAOgB,GACL,GAAIlE,EAAgBE,OAAOC,QAAS,MAAM,IAAIqC,EAE9C,MADAqC,QAAQC,MAAM,wBAAyBZ,GACjC,IAAIzB,EAAkByB,EAChC,CACA,GAAIlE,EAAgBE,OAAOC,QAAS,MAAM,IAAIqC,EAI9C,MAAO,CACHwD,KAAIsD,EAAAA,EAAA,GACGP,EAAcxD,MAAI,IACrBQ,QAGZ,CAAO,CACH,IAAIA,EACJ,MACOoD,YAAapD,SAAchD,EAAaqG,cAAcpD,EAAM,CAAE0C,kBAAiB1I,oBACtF,CAAE,MAAOkE,GACL,GAAIlE,EAAgBE,OAAOC,QAAS,MAAM,IAAIqC,EAE9C,MADAqC,QAAQC,MAAM,wBAAyBZ,GACjC,IAAIzB,EAAkByB,EAChC,CACA,GAAIlE,EAAgBE,OAAOC,QAAS,MAAM,IAAIqC,EAE9C,MAAO,CAAEuD,MACb,CACJ,CAEe,MAAMwD,EAAgBrK,WAAAA,IAAAK,EAAAA,EAAAA,GAAA,kBACE,KAAEA,EAAAA,EAAAA,GAAA,mBACM,KAAI,CAExCiK,wBAAAA,CACHzD,EACA5G,EACAsK,EACAlE,EACAmE,EACA3G,GAEA,OAAO4G,EAAAA,EAAAA,GACHxK,EACCyK,GAAyB7G,EAAa8G,mBAAmBD,EAAcH,EAAU1D,EAAKR,EAAMmE,GAC7F3G,GACF6B,MAAOV,IAEL,MADA4F,EAAAA,GAAOC,KAAK,mCAAmChE,aAAe5G,IAAU+E,GAClEA,GAEd,CAEOjD,cAAAA,GAAgC,IAAA+I,EAAAC,EACnC,OAA0C,QAA1CD,EAAuB,QAAvBC,EAAOtK,KAAKuK,mBAAW,IAAAD,OAAA,EAAhBA,EAAmB,wBAAgB,IAAAD,EAAAA,EAAI,IAClD,CAEA,2BAAaG,CACTC,EACAjL,EACAE,EACA0D,EACAsH,EAAUC,EAAAA,GAAsBC,MAEhC,GAAIxH,EAAayH,UAEb,YADAC,EAAAA,EAAIC,SAAS,CAAEC,OAAQ,yBAI3B,MAAMC,EAAeC,EAAAA,EAAgBC,SAASC,cAAcC,kBAC5D,IAAKrL,KAAKuK,YAAa,CAEnB,MAAMe,EAAQC,EAAAA,GAAMC,aAAaC,EAAAA,OAAS5F,EAAW,qBAErD,SADM5B,QAAQyH,KAAK,CAAC1L,KAAK2L,yBAAyBvI,GAAekI,EAAMM,YAClE5L,KAAKuK,YAEN,OAEAe,EAAMO,OAEd,CAEA,MAAMC,EAAsB,GACtBC,EAAkB,GAExB,IAAK,MAAM1F,KAAQoE,EACXzK,KAAKgM,qBAAqB3F,GAC1B0F,EAAQrO,KAAK2I,GAEbyF,EAAYpO,KAAK2I,GAIzB,GAAIyF,EAAY5O,OAAS,EAAG,CACxB,MAAM,SAAE0O,GAAaL,EAAAA,GAAMC,aAAa/K,EAAqB,CACzDS,SAAU4K,EACV7K,WAAYwJ,EAAMvN,OAClBmE,gBAAiBrB,QAEdiM,SAAwBL,EAC/B,IAAKK,EAAgB,MACzB,CAEA,IAAIC,GAAY,EAGZC,EAA2BlI,QAAQC,UACvC,IAAK,IAAIvG,EAAI,EAAGA,EAAIoO,EAAQ7O,SAAUS,EAAG,CACrC,MAAM0I,EAAO0F,EAAQpO,GACfyO,EAAoBD,EAE1B,IAAKD,EAAW,CACZ,MAAM,SAAEN,GAAaL,EAAAA,GAAMC,aAAaa,EAAAA,EAAqB,CACzDhG,OACAiG,aAAc3O,EACdsD,WAAY8K,EAAQ7O,UAEjB+O,EAAgBM,SAAyBX,EAChD,IAAKK,EAAgB,MACjBM,IACAL,GAAY,EAEpB,CAEAC,GAAanC,EAAAA,EAAAA,GACTxK,EACCyK,GACGjK,KAAKwM,kBACDnG,EACA4D,EACAvK,EACA0D,EACA6H,QAAAA,OAAgBpF,EAChBuG,GAERhJ,EAER,CAEI6H,GAEAH,EAAAA,EAAIC,SAAS,CACTC,OAAQ,iBACRyB,MAAO,KACP/B,YAKRI,EAAAA,EAAIC,SAAS,CACTC,OAAQ0B,EAAAA,EAAOC,yBACfjC,WAER,CAEOkC,iBAAAA,CAAkBlN,GACrB,OAAOM,KAAK6M,WAAWC,OAAQC,IAC3B,MAAMC,GAActN,IAAaqN,EAAWrN,SACtCuN,EACFvN,GACAqN,EAAWrN,UACXA,EAASwN,WAAaH,EAAWrN,SAASwN,UAC1CxN,EAASyN,WAAaJ,EAAWrN,SAASyN,SAE9C,OAAQH,GAAcC,KAAsBF,EAAWzM,WAE/D,CAEO8M,YAAAA,CAAaC,GAChBA,EAAOjN,QACP0K,EAAAA,EAAIC,SAAgC,CAAEC,OAAQ0B,EAAAA,EAAOY,eAAgBD,UACzE,CAEA,uBAAab,CACTnG,EACA7G,EACAE,EACA0D,EACA6H,EACAkB,GAEA,MAAM1M,EAAW4G,EAAK9I,OAAQ4D,EAAAA,EAAAA,IAAG,qBAC3BoM,EAA+E,CACjFC,KAAM/N,EACNmG,KAAM,CACFpE,KAAM6E,EAAK7E,MAEfiM,QAASC,EAAAA,QAAQC,OAIrBC,EAAAA,EAAAA,GAAexK,EAAayK,gBAAiBN,EAAS,KAAMtC,IAC5D6C,EAAAA,EAAAA,GAAeP,EAAS7N,GACpBuL,IACA8C,EAAAA,EAAAA,IAAyBR,EAAStC,GAGlC+C,EAAAA,EAAcC,SAAS,8CACvBC,EAAAA,EAAAA,GAAyBX,GAIzBlH,EAAK9C,OACLgK,EAAQ3H,KAAKuI,SAAW9H,EAAK9C,MAGjC,MAAM8J,EAAS,IAAI/N,EAAWE,EAAQC,EAAUC,EAAU2G,EAAK7E,MAC/DxB,KAAK6M,WAAWnP,KAAK2P,GACrBvC,EAAAA,EAAIC,SAA+B,CAAEC,OAAQ0B,EAAAA,EAAO0B,cAAef,WAOnE,IACI,GAAIhH,EAAK9C,KAAK2E,WAAW,UAAW,CAChCqF,EAAQE,QAAUC,EAAAA,QAAQ9J,MAC1B,IACI,MAAM+B,QAAkBxC,EAAiBC,EAAc5D,EAAQ6G,GAC/DoC,OAAOC,OAAO6E,EAAQ3H,KAAMD,EAChC,CAAE,MAAOpB,GACL,GAAIA,aAAazB,EAEb,MAAMyB,EAGV4F,EAAAA,GAAOhF,MAAMZ,GACbgJ,EAAQE,QAAUC,EAAAA,QAAQC,IAC9B,CACJ,MAAO,GAAItH,EAAK9C,KAAK2E,WAAW,UAAW,CACvCqF,EAAQE,QAAUC,EAAAA,QAAQW,MAC1B,IACI,MAAMC,QAAkBhI,EAAiBD,GACzCoC,OAAOC,OAAO6E,EAAQ3H,KAAM0I,EAChC,CAAE,MAAO/J,GAEL4F,EAAAA,GAAOhF,MAAMZ,GACbgJ,EAAQE,QAAUC,EAAAA,QAAQC,IAC9B,CACJ,MAAO,GAAItH,EAAK9C,KAAK2E,WAAW,UAAW,CACvCqF,EAAQE,QAAUC,EAAAA,QAAQa,MAC1B,IACI,MAAM7G,QAAkBF,EAAiBpE,EAAc5D,EAAQ6G,GAC/DoC,OAAOC,OAAO6E,EAAQ3H,KAAM8B,EAChC,CAAE,MAAOnD,GAEL4F,EAAAA,GAAOhF,MAAMZ,GACbgJ,EAAQE,QAAUC,EAAAA,QAAQC,IAC9B,CACJ,MACIJ,EAAQE,QAAUC,EAAAA,QAAQC,KAG9B,GAAIN,EAAO/M,UAAW,MAAM,IAAIuC,EAChC,MAAM4C,QAAeS,EAAW9C,EAAc5D,EAAQ6G,EA7C1D,SAAoBtG,GAChBsN,EAAOvN,WAAWC,GAClB+K,EAAAA,EAAIC,SAAgC,CAAEC,OAAQ0B,EAAAA,EAAO8B,eAAgBnB,UACzE,EA0C4EA,EAAOhN,iBAI/E,GAHAkN,EAAQlH,KAAOZ,EAAOY,KACtBkH,EAAQnH,IAAMX,EAAOW,IAEjBiH,EAAO/M,UAAW,MAAM,IAAIuC,EAIhC,GAFIsJ,SAAkBA,EAElBkB,EAAO/M,UAAW,MAAM,IAAIuC,EAChC,MAAMiH,GAAWpK,aAAQ,EAARA,EAAUwN,YAAauB,EAAAA,qBAAqBlR,KAAOmC,EAASyN,SAAW,KAElFuB,QAAiBtL,EAAauL,YAAYnP,EAAQsK,QAAAA,EAAY,KAAMyD,GAEtES,EAAAA,EAAcC,SAAS,8CACvBW,EAAAA,EAAAA,GAAoBxL,EAAc5D,EAAQkP,EAASvB,UAGvDrC,EAAAA,EAAIC,SAAgC,CAAEC,OAAQ0B,EAAAA,EAAOmC,eAAgBxB,WACrEvC,EAAAA,EAAIC,SAAS,CAAEC,OAAQ,gBAC3B,CAAE,MAAO7F,GAEL,MAAM2J,EAAiB3J,aAAiBrC,GAAqBqC,EAAMpC,MAAQoC,EAAMpC,MAAQoC,EAQzF,GAJI2J,aAA0BC,EAAAA,WAA2C,MAA9BD,EAAeE,aACtDhP,KAAKuK,YAAc,OAGlB8C,EAAO/M,UAAW,CACnB,IAAI2O,GAAO9N,EAAAA,EAAAA,IAAG,wBAAyB,CAAE1B,SAAU4N,EAAO5N,WACtDqP,aAA0BC,EAAAA,WAA2C,MAA9BD,EAAeE,aACtDC,GAAO9N,EAAAA,EAAAA,IAAG,qBAAsB,CAC5B1B,SAAU4N,EAAO5N,YAGzB8L,EAAAA,GAAMC,aAAa0D,EAAAA,EAAa,CAC5B1M,OAAOrB,EAAAA,EAAAA,IAAG,uBACVgO,YAAaF,IAEjBnE,EAAAA,EAAIC,SAA6B,CAAEC,OAAQ0B,EAAAA,EAAO0C,aAAc/B,SAAQlI,SAC5E,CACJ,CAAE,SACEkK,EAAAA,EAAAA,IAAcrP,KAAK6M,WAAatI,GAAMA,EAAE+K,UAAYjC,EAAOiC,QAC/D,CACJ,CAEQtD,oBAAAA,CAAqB3F,GAAqB,IAAAkJ,EAC9C,aAA4C1J,KAAxB,QAAhB0J,EAAAvP,KAAKuK,mBAAW,IAAAgF,OAAA,EAAhBA,EAAmB,mBAAkClJ,EAAK7E,KAAOxB,KAAKuK,YAAY,iBAI1F,CAEQoB,wBAAAA,CAAyBvI,GAC7B,OAAyB,OAArBpD,KAAKuK,YAA6BtG,QAAQC,WAE9CiG,EAAAA,GAAOqF,IAAI,2BACJpM,EACFqM,iBACA9K,KAAM+K,IACHvF,EAAAA,GAAOqF,IAAI,iCAAkCE,GACtCA,IAEVzK,MAAM,KAEHkF,EAAAA,GAAOqF,IAAI,mEACJ,CAAC,IAEX7K,KAAM+K,IACH1P,KAAKuK,YAAcmF,IAE/B,CAEA,qBAAcC,GAIV,YAHiC9J,IAA7B+J,OAAOC,oBACPD,OAAOC,kBAAoB,IAAIjG,GAE5BgG,OAAOC,iBAClB,E,+DCprBG,SAAS3B,EAAyBX,GACrCA,EAAQ,kCAAoC,CACxCuC,YAAaC,KAAKC,MAE1B,CASO,SAASpB,EAAoBqB,EAAsBC,EAAkBC,GAExEF,EAAOG,UAAUF,EAAU,gCAAiC,CACxD,iCAAkC,CAC9BC,WAAYA,EACZE,WAAYN,KAAKC,MACjBM,KAAM,cAGlB,C","sources":["webpack://element-web/./node_modules/png-chunks-extract/index.js","webpack://element-web/./node_modules/png-chunks-extract/node_modules/crc-32/crc32.js","webpack://element-web/./src/models/RoomUpload.ts","webpack://element-web/./src/components/views/dialogs/UploadFailureDialog.tsx","webpack://element-web/./src/ContentMessages.ts","webpack://element-web/./src/sendTimePerformanceMetrics.ts"],"sourcesContent":["var crc32 = require('crc-32')\n\nmodule.exports = extractChunks\n\n// Used for fast-ish conversion between uint8s and uint32s/int32s.\n// Also required in order to remain agnostic for both Node Buffers and\n// Uint8Arrays.\nvar uint8 = new Uint8Array(4)\nvar int32 = new Int32Array(uint8.buffer)\nvar uint32 = new Uint32Array(uint8.buffer)\n\nfunction extractChunks (data) {\n  if (data[0] !== 0x89) throw new Error('Invalid .png file header')\n  if (data[1] !== 0x50) throw new Error('Invalid .png file header')\n  if (data[2] !== 0x4E) throw new Error('Invalid .png file header')\n  if (data[3] !== 0x47) throw new Error('Invalid .png file header')\n  if (data[4] !== 0x0D) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n  if (data[5] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n  if (data[6] !== 0x1A) throw new Error('Invalid .png file header')\n  if (data[7] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n\n  var ended = false\n  var chunks = []\n  var idx = 8\n\n  while (idx < data.length) {\n    // Read the length of the current chunk,\n    // which is stored as a Uint32.\n    uint8[3] = data[idx++]\n    uint8[2] = data[idx++]\n    uint8[1] = data[idx++]\n    uint8[0] = data[idx++]\n\n    // Chunk includes name/type for CRC check (see below).\n    var length = uint32[0] + 4\n    var chunk = new Uint8Array(length)\n    chunk[0] = data[idx++]\n    chunk[1] = data[idx++]\n    chunk[2] = data[idx++]\n    chunk[3] = data[idx++]\n\n    // Get the name in ASCII for identification.\n    var name = (\n      String.fromCharCode(chunk[0]) +\n      String.fromCharCode(chunk[1]) +\n      String.fromCharCode(chunk[2]) +\n      String.fromCharCode(chunk[3])\n    )\n\n    // The IHDR header MUST come first.\n    if (!chunks.length && name !== 'IHDR') {\n      throw new Error('IHDR header missing')\n    }\n\n    // The IEND header marks the end of the file,\n    // so on discovering it break out of the loop.\n    if (name === 'IEND') {\n      ended = true\n      chunks.push({\n        name: name,\n        data: new Uint8Array(0)\n      })\n\n      break\n    }\n\n    // Read the contents of the chunk out of the main buffer.\n    for (var i = 4; i < length; i++) {\n      chunk[i] = data[idx++]\n    }\n\n    // Read out the CRC value for comparison.\n    // It's stored as an Int32.\n    uint8[3] = data[idx++]\n    uint8[2] = data[idx++]\n    uint8[1] = data[idx++]\n    uint8[0] = data[idx++]\n\n    var crcActual = int32[0]\n    var crcExpect = crc32.buf(chunk)\n    if (crcExpect !== crcActual) {\n      throw new Error(\n        'CRC values for ' + name + ' header do not match, PNG file is likely corrupted'\n      )\n    }\n\n    // The chunk data is now copied to remove the 4 preceding\n    // bytes used for the chunk name/type.\n    var chunkData = new Uint8Array(chunk.buffer.slice(4))\n\n    chunks.push({\n      name: name,\n      data: chunkData\n    })\n  }\n\n  if (!ended) {\n    throw new Error('.png file ended prematurely: no IEND header was found')\n  }\n\n  return chunks\n}\n","/* crc32.js (C) 2014-2015 SheetJS -- http://sheetjs.com */\n/* vim: set ts=2: */\nvar CRC32;\n(function (factory) {\n\tif(typeof DO_NOT_EXPORT_CRC === 'undefined') {\n\t\tif('object' === typeof exports) {\n\t\t\tfactory(exports);\n\t\t} else if ('function' === typeof define && define.amd) {\n\t\t\tdefine(function () {\n\t\t\t\tvar module = {};\n\t\t\t\tfactory(module);\n\t\t\t\treturn module;\n\t\t\t});\n\t\t} else {\n\t\t  factory(CRC32 = {});\n\t\t}\n\t} else {\n\t\tfactory(CRC32 = {});\n\t}\n}(function(CRC32) {\nCRC32.version = '0.3.0';\n/* see perf/crc32table.js */\nfunction signed_crc_table() {\n\tvar c = 0, table = new Array(256);\n\n\tfor(var n =0; n != 256; ++n){\n\t\tc = n;\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\ttable[n] = c;\n\t}\n\n\treturn typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;\n}\n\nvar table = signed_crc_table();\n/* charCodeAt is the best approach for binary strings */\nvar use_buffer = typeof Buffer !== 'undefined';\nfunction crc32_bstr(bstr) {\n\tif(bstr.length > 32768) if(use_buffer) return crc32_buf_8(new Buffer(bstr));\n\tvar crc = -1, L = bstr.length - 1;\n\tfor(var i = 0; i < L;) {\n\t\tcrc =  table[(crc ^ bstr.charCodeAt(i++)) & 0xFF] ^ (crc >>> 8);\n\t\tcrc =  table[(crc ^ bstr.charCodeAt(i++)) & 0xFF] ^ (crc >>> 8);\n\t}\n\tif(i === L) crc = (crc >>> 8) ^ table[(crc ^ bstr.charCodeAt(i)) & 0xFF];\n\treturn crc ^ -1;\n}\n\nfunction crc32_buf(buf) {\n\tif(buf.length > 10000) return crc32_buf_8(buf);\n\tfor(var crc = -1, i = 0, L=buf.length-3; i < L;) {\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t}\n\twhile(i < L+3) crc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\treturn crc ^ -1;\n}\n\nfunction crc32_buf_8(buf) {\n\tfor(var crc = -1, i = 0, L=buf.length-7; i < L;) {\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t}\n\twhile(i < L+7) crc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\treturn crc ^ -1;\n}\n\n/* much much faster to intertwine utf8 and crc */\nfunction crc32_str(str) {\n\tfor(var crc = -1, i = 0, L=str.length, c, d; i < L;) {\n\t\tc = str.charCodeAt(i++);\n\t\tif(c < 0x80) {\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ c) & 0xFF];\n\t\t} else if(c < 0x800) {\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (192|((c>>6)&31))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|(c&63))) & 0xFF];\n\t\t} else if(c >= 0xD800 && c < 0xE000) {\n\t\t\tc = (c&1023)+64; d = str.charCodeAt(i++) & 1023;\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (240|((c>>8)&7))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|((c>>2)&63))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|((d>>6)&15)|(c&3))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|(d&63))) & 0xFF];\n\t\t} else {\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (224|((c>>12)&15))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|((c>>6)&63))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|(c&63))) & 0xFF];\n\t\t}\n\t}\n\treturn crc ^ -1;\n}\nCRC32.table = table;\nCRC32.bstr = crc32_bstr;\nCRC32.buf = crc32_buf;\nCRC32.str = crc32_str;\n}));\n","/*\nCopyright 2024 New Vector Ltd.\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport { type IEventRelation, type UploadProgress } from \"matrix-js-sdk/src/matrix\";\nimport { type EncryptedFile } from \"matrix-js-sdk/src/types\";\n\nexport class RoomUpload {\n    public readonly abortController = new AbortController();\n    public promise?: Promise<{ url?: string; file?: EncryptedFile }>;\n    private uploaded = 0;\n\n    public constructor(\n        public readonly roomId: string,\n        public readonly fileName: string,\n        public readonly relation?: IEventRelation,\n        public fileSize = 0,\n    ) {}\n\n    public onProgress(progress: UploadProgress): void {\n        this.uploaded = progress.loaded;\n        this.fileSize = progress.total;\n    }\n\n    public abort(): void {\n        this.abortController.abort();\n    }\n\n    public get cancelled(): boolean {\n        return this.abortController.signal.aborted;\n    }\n\n    public get total(): number {\n        return this.fileSize;\n    }\n\n    public get loaded(): number {\n        return this.uploaded;\n    }\n}\n","/*\nCopyright 2019-2024 New Vector Ltd.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport React from \"react\";\n\nimport { _t } from \"../../../languageHandler\";\nimport type ContentMessages from \"../../../ContentMessages\";\nimport BaseDialog from \"./BaseDialog\";\nimport DialogButtons from \"../elements/DialogButtons\";\nimport { fileSize } from \"../../../utils/FileUtils\";\n\ninterface IProps {\n    badFiles: File[];\n    totalFiles: number;\n    contentMessages: ContentMessages;\n    onFinished(upload?: boolean): void;\n}\n\n/*\n * Tells the user about files we know cannot be uploaded before we even try uploading\n * them. This is named fairly generically but the only thing we check right now is\n * the size of the file.\n */\nexport default class UploadFailureDialog extends React.Component<IProps> {\n    private onCancelClick = (): void => {\n        this.props.onFinished(false);\n    };\n\n    private onUploadClick = (): void => {\n        this.props.onFinished(true);\n    };\n\n    public render(): React.ReactNode {\n        let message;\n        let preview;\n        let buttons;\n        if (this.props.totalFiles === 1 && this.props.badFiles.length === 1) {\n            message = _t(\n                \"upload_file|error_file_too_large\",\n                {\n                    limit: fileSize(this.props.contentMessages.getUploadLimit()!),\n                    sizeOfThisFile: fileSize(this.props.badFiles[0].size),\n                },\n                {\n                    b: (sub) => <strong>{sub}</strong>,\n                },\n            );\n            buttons = (\n                <DialogButtons\n                    primaryButton={_t(\"action|ok\")}\n                    hasCancel={false}\n                    onPrimaryButtonClick={this.onCancelClick}\n                    focus={true}\n                />\n            );\n        } else if (this.props.totalFiles === this.props.badFiles.length) {\n            message = _t(\n                \"upload_file|error_files_too_large\",\n                {\n                    limit: fileSize(this.props.contentMessages.getUploadLimit()!),\n                },\n                {\n                    b: (sub) => <strong>{sub}</strong>,\n                },\n            );\n            buttons = (\n                <DialogButtons\n                    primaryButton={_t(\"action|ok\")}\n                    hasCancel={false}\n                    onPrimaryButtonClick={this.onCancelClick}\n                    focus={true}\n                />\n            );\n        } else {\n            message = _t(\n                \"upload_file|error_some_files_too_large\",\n                {\n                    limit: fileSize(this.props.contentMessages.getUploadLimit()!),\n                },\n                {\n                    b: (sub) => <strong>{sub}</strong>,\n                },\n            );\n            const howManyOthers = this.props.totalFiles - this.props.badFiles.length;\n            buttons = (\n                <DialogButtons\n                    primaryButton={_t(\"upload_file|upload_n_others_button\", { count: howManyOthers })}\n                    onPrimaryButtonClick={this.onUploadClick}\n                    hasCancel={true}\n                    cancelButton={_t(\"upload_file|cancel_all_button\")}\n                    onCancel={this.onCancelClick}\n                    focus={true}\n                />\n            );\n        }\n\n        return (\n            <BaseDialog\n                className=\"mx_UploadFailureDialog\"\n                onFinished={this.onCancelClick}\n                title={_t(\"upload_file|error_title\")}\n                contentId=\"mx_Dialog_content\"\n            >\n                <div id=\"mx_Dialog_content\">\n                    {message}\n                    {preview}\n                </div>\n\n                {buttons}\n            </BaseDialog>\n        );\n    }\n}\n","/*\r\nCopyright 2024 New Vector Ltd.\r\nCopyright 2020 The Matrix.org Foundation C.I.C.\r\nCopyright 2019 New Vector Ltd\r\nCopyright 2015, 2016 OpenMarket Ltd\r\n\r\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\r\nPlease see LICENSE files in the repository root for full details.\r\n*/\r\n\r\nimport {\r\n    type MatrixClient,\r\n    MsgType,\r\n    HTTPError,\r\n    type IEventRelation,\r\n    type ISendEventResponse,\r\n    type MatrixEvent,\r\n    type UploadOpts,\r\n    type UploadProgress,\r\n    THREAD_RELATION_TYPE,\r\n} from \"matrix-js-sdk/src/matrix\";\r\nimport {\r\n    type ImageInfo,\r\n    type AudioInfo,\r\n    type VideoInfo,\r\n    type EncryptedFile,\r\n    type MediaEventContent,\r\n    type MediaEventInfo,\r\n} from \"matrix-js-sdk/src/types\";\r\nimport encrypt from \"matrix-encrypt-attachment\";\r\nimport extractPngChunks from \"png-chunks-extract\";\r\nimport { logger } from \"matrix-js-sdk/src/logger\";\r\nimport { removeElement } from \"matrix-js-sdk/src/utils\";\r\n\r\nimport dis from \"./dispatcher/dispatcher\";\r\nimport { _t } from \"./languageHandler\";\r\nimport Modal from \"./Modal\";\r\nimport Spinner from \"./components/views/elements/Spinner\";\r\nimport { Action } from \"./dispatcher/actions\";\r\nimport {\r\n    type UploadCanceledPayload,\r\n    type UploadErrorPayload,\r\n    type UploadFinishedPayload,\r\n    type UploadProgressPayload,\r\n    type UploadStartedPayload,\r\n} from \"./dispatcher/payloads/UploadPayload\";\r\nimport { RoomUpload } from \"./models/RoomUpload\";\r\nimport SettingsStore from \"./settings/SettingsStore\";\r\nimport { decorateStartSendingTime, sendRoundTripMetric } from \"./sendTimePerformanceMetrics\";\r\nimport { TimelineRenderingType } from \"./contexts/RoomContext\";\r\nimport { addReplyToMessageContent } from \"./utils/Reply\";\r\nimport ErrorDialog from \"./components/views/dialogs/ErrorDialog\";\r\nimport UploadFailureDialog from \"./components/views/dialogs/UploadFailureDialog\";\r\nimport UploadConfirmDialog from \"./components/views/dialogs/UploadConfirmDialog\";\r\nimport { createThumbnail } from \"./utils/image-media\";\r\nimport { attachMentions, attachRelation } from \"./utils/messages.ts\";\r\nimport { doMaybeLocalRoomAction } from \"./utils/local-room\";\r\nimport { SdkContextClass } from \"./contexts/SDKContext\";\r\nimport { blobIsAnimated } from \"./utils/Image.ts\";\r\n\r\n// scraped out of a macOS hidpi (5660ppm) screenshot png\r\n//                  5669 px (x-axis)      , 5669 px (y-axis)      , per metre\r\nconst PHYS_HIDPI = [0x00, 0x00, 0x16, 0x25, 0x00, 0x00, 0x16, 0x25, 0x01];\r\n\r\nexport class UploadCanceledError extends Error {}\r\nexport class UploadFailedError extends Error {\r\n    public constructor(cause: any) {\r\n        super();\r\n        this.cause = cause;\r\n    }\r\n}\r\n\r\ninterface IMediaConfig {\r\n    \"m.upload.size\"?: number;\r\n}\r\n\r\n/**\r\n * Load a file into a newly created image element.\r\n *\r\n * @param {File} imageFile The file to load in an image element.\r\n * @return {Promise} A promise that resolves with the html image element.\r\n */\r\nasync function loadImageElement(imageFile: File): Promise<{\r\n    width: number;\r\n    height: number;\r\n    img: HTMLImageElement;\r\n}> {\r\n    // Load the file into an html element\r\n    const img = new Image();\r\n    const objectUrl = URL.createObjectURL(imageFile);\r\n    const imgPromise = new Promise((resolve, reject) => {\r\n        img.onload = function (): void {\r\n            URL.revokeObjectURL(objectUrl);\r\n            resolve(img);\r\n        };\r\n        img.onerror = function (e): void {\r\n            reject(e);\r\n        };\r\n    });\r\n    img.src = objectUrl;\r\n\r\n    // check for hi-dpi PNGs and fudge display resolution as needed.\r\n    // this is mainly needed for macOS screencaps\r\n    let parsePromise = Promise.resolve(false);\r\n    if (imageFile.type === \"image/png\") {\r\n        // in practice macOS happens to order the chunks so they fall in\r\n        // the first 0x1000 bytes (thanks to a massive ICC header).\r\n        // Thus we could slice the file down to only sniff the first 0x1000\r\n        // bytes (but this makes extractPngChunks choke on the corrupt file)\r\n        const headers = imageFile; //.slice(0, 0x1000);\r\n        parsePromise = readFileAsArrayBuffer(headers)\r\n            .then((arrayBuffer) => {\r\n                const buffer = new Uint8Array(arrayBuffer);\r\n                const chunks = extractPngChunks(buffer);\r\n                for (const chunk of chunks) {\r\n                    if (chunk.name === \"pHYs\") {\r\n                        if (chunk.data.byteLength !== PHYS_HIDPI.length) return false;\r\n                        return chunk.data.every((val, i) => val === PHYS_HIDPI[i]);\r\n                    }\r\n                }\r\n                return false;\r\n            })\r\n            .catch((e) => {\r\n                console.error(\"Failed to parse PNG\", e);\r\n                return false;\r\n            });\r\n    }\r\n\r\n    const [hidpi] = await Promise.all([parsePromise, imgPromise]);\r\n    const width = hidpi ? img.width >> 1 : img.width;\r\n    const height = hidpi ? img.height >> 1 : img.height;\r\n    return { width, height, img };\r\n}\r\n\r\n// Minimum size for image files before we generate a thumbnail for them.\r\nconst IMAGE_SIZE_THRESHOLD_THUMBNAIL = 1 << 15; // 32KB\r\n// Minimum size improvement for image thumbnails, if both are not met then don't bother uploading thumbnail.\r\nconst IMAGE_THUMBNAIL_MIN_REDUCTION_SIZE = 1 << 16; // 1MB\r\nconst IMAGE_THUMBNAIL_MIN_REDUCTION_PERCENT = 0.1; // 10%\r\n// We don't apply these thresholds to video thumbnails as a poster image is always useful\r\n// and videos tend to be much larger.\r\n\r\n// Image mime types for which to always include a thumbnail for even if it is larger than the input for wider support.\r\nconst ALWAYS_INCLUDE_THUMBNAIL = [\"image/avif\", \"image/webp\"];\r\n\r\n/**\r\n * Read the metadata for an image file and create and upload a thumbnail of the image.\r\n *\r\n * @param {MatrixClient} matrixClient A matrixClient to upload the thumbnail with.\r\n * @param {String} roomId The ID of the room the image will be uploaded in.\r\n * @param {File} imageFile The image to read and thumbnail.\r\n * @return {Promise} A promise that resolves with the attachment info.\r\n */\r\nasync function infoForImageFile(matrixClient: MatrixClient, roomId: string, imageFile: File): Promise<ImageInfo> {\r\n    let thumbnailType = \"image/png\";\r\n    if (imageFile.type === \"image/jpeg\") {\r\n        thumbnailType = \"image/jpeg\";\r\n    }\r\n\r\n    // We don't await this immediately so it can happen in the background\r\n    const isAnimatedPromise = blobIsAnimated(imageFile);\r\n\r\n    const imageElement = await loadImageElement(imageFile);\r\n\r\n    const result = await createThumbnail(imageElement.img, imageElement.width, imageElement.height, thumbnailType);\r\n    const imageInfo = result.info;\r\n\r\n    const isAnimated = await isAnimatedPromise;\r\n    if (isAnimated !== undefined) {\r\n        imageInfo[\"org.matrix.msc4230.is_animated\"] = await isAnimatedPromise;\r\n    }\r\n\r\n    // For lesser supported image types, always include the thumbnail even if it is larger\r\n    if (!ALWAYS_INCLUDE_THUMBNAIL.includes(imageFile.type)) {\r\n        // we do all sizing checks here because we still rely on thumbnail generation for making a blurhash from.\r\n        const sizeDifference = imageFile.size - imageInfo.thumbnail_info!.size!;\r\n        if (\r\n            // image is small enough already\r\n            imageFile.size <= IMAGE_SIZE_THRESHOLD_THUMBNAIL ||\r\n            // thumbnail is not sufficiently smaller than original\r\n            (sizeDifference <= IMAGE_THUMBNAIL_MIN_REDUCTION_SIZE &&\r\n                sizeDifference <= imageFile.size * IMAGE_THUMBNAIL_MIN_REDUCTION_PERCENT)\r\n        ) {\r\n            delete imageInfo[\"thumbnail_info\"];\r\n            return imageInfo;\r\n        }\r\n    }\r\n\r\n    const uploadResult = await uploadFile(matrixClient, roomId, result.thumbnail);\r\n\r\n    imageInfo[\"thumbnail_url\"] = uploadResult.url;\r\n    imageInfo[\"thumbnail_file\"] = uploadResult.file;\r\n    return imageInfo;\r\n}\r\n\r\n/**\r\n * Load a file into a newly created audio element and load the metadata\r\n *\r\n * @param {File} audioFile The file to load in an audio element.\r\n * @return {Promise} A promise that resolves with the audio element.\r\n */\r\nfunction loadAudioElement(audioFile: File): Promise<HTMLAudioElement> {\r\n    return new Promise((resolve, reject) => {\r\n        // Load the file into a html element\r\n        const audio = document.createElement(\"audio\");\r\n        audio.preload = \"metadata\";\r\n        audio.muted = true;\r\n\r\n        const reader = new FileReader();\r\n\r\n        reader.onload = function (ev): void {\r\n            audio.onloadedmetadata = async function (): Promise<void> {\r\n                resolve(audio);\r\n            };\r\n            audio.onerror = function (e): void {\r\n                reject(e);\r\n            };\r\n\r\n            audio.src = ev.target?.result as string;\r\n        };\r\n        reader.onerror = function (e): void {\r\n            reject(e);\r\n        };\r\n        reader.readAsDataURL(audioFile);\r\n    });\r\n}\r\n\r\n/**\r\n * Read the metadata for an audio file.\r\n *\r\n * @param {File} audioFile The audio to read.\r\n * @return {Promise} A promise that resolves with the attachment info.\r\n */\r\nasync function infoForAudioFile(audioFile: File): Promise<AudioInfo> {\r\n    const audio = await loadAudioElement(audioFile);\r\n    return { duration: Math.ceil(audio.duration * 1000) };\r\n}\r\n\r\n/**\r\n * Load a file into a newly created video element and pull some strings\r\n * in an attempt to guarantee the first frame will be showing.\r\n *\r\n * @param {File} videoFile The file to load in a video element.\r\n * @return {Promise} A promise that resolves with the video element.\r\n */\r\nfunction loadVideoElement(videoFile: File): Promise<HTMLVideoElement> {\r\n    return new Promise((resolve, reject) => {\r\n        // Load the file into a html element\r\n        const video = document.createElement(\"video\");\r\n        video.preload = \"metadata\";\r\n        video.playsInline = true;\r\n        video.muted = true;\r\n\r\n        const reader = new FileReader();\r\n\r\n        reader.onload = function (ev): void {\r\n            // Wait until we have enough data to thumbnail the first frame.\r\n            video.onloadeddata = async function (): Promise<void> {\r\n                resolve(video);\r\n                video.pause();\r\n            };\r\n            video.onerror = function (e): void {\r\n                reject(e);\r\n            };\r\n\r\n            let dataUrl = ev.target?.result as string;\r\n            // Chrome chokes on quicktime but likes mp4, and `file.type` is\r\n            // read only, so do this horrible hack to unbreak quicktime\r\n            if (dataUrl?.startsWith(\"data:video/quicktime;\")) {\r\n                dataUrl = dataUrl.replace(\"data:video/quicktime;\", \"data:video/mp4;\");\r\n            }\r\n\r\n            video.src = dataUrl;\r\n            video.load();\r\n            video.play();\r\n        };\r\n        reader.onerror = function (e): void {\r\n            reject(e);\r\n        };\r\n        reader.readAsDataURL(videoFile);\r\n    });\r\n}\r\n\r\n/**\r\n * Read the metadata for a video file and create and upload a thumbnail of the video.\r\n *\r\n * @param {MatrixClient} matrixClient A matrixClient to upload the thumbnail with.\r\n * @param {String} roomId The ID of the room the video will be uploaded to.\r\n * @param {File} videoFile The video to read and thumbnail.\r\n * @return {Promise} A promise that resolves with the attachment info.\r\n */\r\nfunction infoForVideoFile(matrixClient: MatrixClient, roomId: string, videoFile: File): Promise<VideoInfo> {\r\n    const thumbnailType = \"image/jpeg\";\r\n\r\n    const videoInfo: VideoInfo = {};\r\n    return loadVideoElement(videoFile)\r\n        .then((video) => {\r\n            videoInfo.duration = Math.ceil(video.duration * 1000);\r\n            return createThumbnail(video, video.videoWidth, video.videoHeight, thumbnailType);\r\n        })\r\n        .then((result) => {\r\n            Object.assign(videoInfo, result.info);\r\n            return uploadFile(matrixClient, roomId, result.thumbnail);\r\n        })\r\n        .then((result) => {\r\n            videoInfo.thumbnail_url = result.url;\r\n            videoInfo.thumbnail_file = result.file;\r\n            return videoInfo;\r\n        });\r\n}\r\n\r\n/**\r\n * Read the file as an ArrayBuffer.\r\n * @param {File} file The file to read\r\n * @return {Promise} A promise that resolves with an ArrayBuffer when the file\r\n *   is read.\r\n */\r\nfunction readFileAsArrayBuffer(file: File | Blob): Promise<ArrayBuffer> {\r\n    return new Promise((resolve, reject) => {\r\n        const reader = new FileReader();\r\n        reader.onload = function (e): void {\r\n            resolve(e.target?.result as ArrayBuffer);\r\n        };\r\n        reader.onerror = function (e): void {\r\n            reject(e);\r\n        };\r\n        reader.readAsArrayBuffer(file);\r\n    });\r\n}\r\n\r\n/**\r\n * Upload the file to the content repository.\r\n * If the room is encrypted then encrypt the file before uploading.\r\n *\r\n * @param {MatrixClient} matrixClient The matrix client to upload the file with.\r\n * @param {String} roomId The ID of the room being uploaded to.\r\n * @param {File} file The file to upload.\r\n * @param {Function?} progressHandler optional callback to be called when a chunk of\r\n *    data is uploaded.\r\n * @param {AbortController?} controller optional abortController to use for this upload.\r\n * @return {Promise} A promise that resolves with an object.\r\n *  If the file is unencrypted then the object will have a \"url\" key.\r\n *  If the file is encrypted then the object will have a \"file\" key.\r\n */\r\nexport async function uploadFile(\r\n    matrixClient: MatrixClient,\r\n    roomId: string,\r\n    file: File | Blob,\r\n    progressHandler?: UploadOpts[\"progressHandler\"],\r\n    controller?: AbortController,\r\n): Promise<{ url?: string; file?: EncryptedFile }> {\r\n    const abortController = controller ?? new AbortController();\r\n\r\n    // If the room is encrypted then encrypt the file before uploading it.\r\n    if (await matrixClient.getCrypto()?.isEncryptionEnabledInRoom(roomId)) {\r\n        // First read the file into memory.\r\n        const data = await readFileAsArrayBuffer(file);\r\n        if (abortController.signal.aborted) throw new UploadCanceledError();\r\n\r\n        // Then encrypt the file.\r\n        const encryptResult = await encrypt.encryptAttachment(data);\r\n        if (abortController.signal.aborted) throw new UploadCanceledError();\r\n\r\n        // Pass the encrypted data as a Blob to the uploader.\r\n        const blob = new Blob([encryptResult.data]);\r\n\r\n        let url: string;\r\n        try {\r\n            ({ content_uri: url } = await matrixClient.uploadContent(blob, {\r\n                progressHandler,\r\n                abortController,\r\n                includeFilename: false,\r\n                type: \"application/octet-stream\",\r\n            }));\r\n        } catch (e) {\r\n            if (abortController.signal.aborted) throw new UploadCanceledError();\r\n            console.error(\"Failed to upload file\", e);\r\n            throw new UploadFailedError(e);\r\n        }\r\n        if (abortController.signal.aborted) throw new UploadCanceledError();\r\n\r\n        // If the attachment is encrypted then bundle the URL along with the information\r\n        // needed to decrypt the attachment and add it under a file key.\r\n        return {\r\n            file: {\r\n                ...encryptResult.info,\r\n                url,\r\n            } as EncryptedFile,\r\n        };\r\n    } else {\r\n        let url: string;\r\n        try {\r\n            ({ content_uri: url } = await matrixClient.uploadContent(file, { progressHandler, abortController }));\r\n        } catch (e) {\r\n            if (abortController.signal.aborted) throw new UploadCanceledError();\r\n            console.error(\"Failed to upload file\", e);\r\n            throw new UploadFailedError(e);\r\n        }\r\n        if (abortController.signal.aborted) throw new UploadCanceledError();\r\n        // If the attachment isn't encrypted then include the URL directly.\r\n        return { url };\r\n    }\r\n}\r\n\r\nexport default class ContentMessages {\r\n    private inprogress: RoomUpload[] = [];\r\n    private mediaConfig: IMediaConfig | null = null;\r\n\r\n    public sendStickerContentToRoom(\r\n        url: string,\r\n        roomId: string,\r\n        threadId: string | null,\r\n        info: ImageInfo,\r\n        text: string,\r\n        matrixClient: MatrixClient,\r\n    ): Promise<ISendEventResponse> {\r\n        return doMaybeLocalRoomAction(\r\n            roomId,\r\n            (actualRoomId: string) => matrixClient.sendStickerMessage(actualRoomId, threadId, url, info, text),\r\n            matrixClient,\r\n        ).catch((e) => {\r\n            logger.warn(`Failed to send content with URL ${url} to room ${roomId}`, e);\r\n            throw e;\r\n        });\r\n    }\r\n\r\n    public getUploadLimit(): number | null {\r\n        return this.mediaConfig?.[\"m.upload.size\"] ?? null;\r\n    }\r\n\r\n    public async sendContentListToRoom(\r\n        files: File[],\r\n        roomId: string,\r\n        relation: IEventRelation | undefined,\r\n        matrixClient: MatrixClient,\r\n        context = TimelineRenderingType.Room,\r\n    ): Promise<void> {\r\n        if (matrixClient.isGuest()) {\r\n            dis.dispatch({ action: \"require_registration\" });\r\n            return;\r\n        }\r\n\r\n        const replyToEvent = SdkContextClass.instance.roomViewStore.getQuotingEvent();\r\n        if (!this.mediaConfig) {\r\n            // hot-path optimization to not flash a spinner if we don't need to\r\n            const modal = Modal.createDialog(Spinner, undefined, \"mx_Dialog_spinner\");\r\n            await Promise.race([this.ensureMediaConfigFetched(matrixClient), modal.finished]);\r\n            if (!this.mediaConfig) {\r\n                // User cancelled by clicking away on the spinner\r\n                return;\r\n            } else {\r\n                modal.close();\r\n            }\r\n        }\r\n\r\n        const tooBigFiles: File[] = [];\r\n        const okFiles: File[] = [];\r\n\r\n        for (const file of files) {\r\n            if (this.isFileSizeAcceptable(file)) {\r\n                okFiles.push(file);\r\n            } else {\r\n                tooBigFiles.push(file);\r\n            }\r\n        }\r\n\r\n        if (tooBigFiles.length > 0) {\r\n            const { finished } = Modal.createDialog(UploadFailureDialog, {\r\n                badFiles: tooBigFiles,\r\n                totalFiles: files.length,\r\n                contentMessages: this,\r\n            });\r\n            const [shouldContinue] = await finished;\r\n            if (!shouldContinue) return;\r\n        }\r\n\r\n        let uploadAll = false;\r\n        // Promise to complete before sending next file into room, used for synchronisation of file-sending\r\n        // to match the order the files were specified in\r\n        let promBefore: Promise<any> = Promise.resolve();\r\n        for (let i = 0; i < okFiles.length; ++i) {\r\n            const file = okFiles[i];\r\n            const loopPromiseBefore = promBefore;\r\n\r\n            if (!uploadAll) {\r\n                const { finished } = Modal.createDialog(UploadConfirmDialog, {\r\n                    file,\r\n                    currentIndex: i,\r\n                    totalFiles: okFiles.length,\r\n                });\r\n                const [shouldContinue, shouldUploadAll] = await finished;\r\n                if (!shouldContinue) break;\r\n                if (shouldUploadAll) {\r\n                    uploadAll = true;\r\n                }\r\n            }\r\n\r\n            promBefore = doMaybeLocalRoomAction(\r\n                roomId,\r\n                (actualRoomId) =>\r\n                    this.sendContentToRoom(\r\n                        file,\r\n                        actualRoomId,\r\n                        relation,\r\n                        matrixClient,\r\n                        replyToEvent ?? undefined,\r\n                        loopPromiseBefore,\r\n                    ),\r\n                matrixClient,\r\n            );\r\n        }\r\n\r\n        if (replyToEvent) {\r\n            // Clear event being replied to\r\n            dis.dispatch({\r\n                action: \"reply_to_event\",\r\n                event: null,\r\n                context,\r\n            });\r\n        }\r\n\r\n        // Focus the correct composer\r\n        dis.dispatch({\r\n            action: Action.FocusSendMessageComposer,\r\n            context,\r\n        });\r\n    }\r\n\r\n    public getCurrentUploads(relation?: IEventRelation): RoomUpload[] {\r\n        return this.inprogress.filter((roomUpload) => {\r\n            const noRelation = !relation && !roomUpload.relation;\r\n            const matchingRelation =\r\n                relation &&\r\n                roomUpload.relation &&\r\n                relation.rel_type === roomUpload.relation.rel_type &&\r\n                relation.event_id === roomUpload.relation.event_id;\r\n\r\n            return (noRelation || matchingRelation) && !roomUpload.cancelled;\r\n        });\r\n    }\r\n\r\n    public cancelUpload(upload: RoomUpload): void {\r\n        upload.abort();\r\n        dis.dispatch<UploadCanceledPayload>({ action: Action.UploadCanceled, upload });\r\n    }\r\n\r\n    public async sendContentToRoom(\r\n        file: File,\r\n        roomId: string,\r\n        relation: IEventRelation | undefined,\r\n        matrixClient: MatrixClient,\r\n        replyToEvent: MatrixEvent | undefined,\r\n        promBefore?: Promise<any>,\r\n    ): Promise<void> {\r\n        const fileName = file.name || _t(\"common|attachment\");\r\n        const content: Omit<MediaEventContent, \"info\"> & { info: Partial<MediaEventInfo> } = {\r\n            body: fileName,\r\n            info: {\r\n                size: file.size,\r\n            },\r\n            msgtype: MsgType.File, // set more specifically later\r\n        };\r\n\r\n        // Attach mentions, which really only applies if there's a replyToEvent.\r\n        attachMentions(matrixClient.getSafeUserId(), content, null, replyToEvent);\r\n        attachRelation(content, relation);\r\n        if (replyToEvent) {\r\n            addReplyToMessageContent(content, replyToEvent);\r\n        }\r\n\r\n        if (SettingsStore.getValue(\"Performance.addSendMessageTimingMetadata\")) {\r\n            decorateStartSendingTime(content);\r\n        }\r\n\r\n        // if we have a mime type for the file, add it to the message metadata\r\n        if (file.type) {\r\n            content.info.mimetype = file.type;\r\n        }\r\n\r\n        const upload = new RoomUpload(roomId, fileName, relation, file.size);\r\n        this.inprogress.push(upload);\r\n        dis.dispatch<UploadStartedPayload>({ action: Action.UploadStarted, upload });\r\n\r\n        function onProgress(progress: UploadProgress): void {\r\n            upload.onProgress(progress);\r\n            dis.dispatch<UploadProgressPayload>({ action: Action.UploadProgress, upload });\r\n        }\r\n\r\n        try {\r\n            if (file.type.startsWith(\"image/\")) {\r\n                content.msgtype = MsgType.Image;\r\n                try {\r\n                    const imageInfo = await infoForImageFile(matrixClient, roomId, file);\r\n                    Object.assign(content.info, imageInfo);\r\n                } catch (e) {\r\n                    if (e instanceof UploadFailedError) {\r\n                        // re-throw to main upload error handler\r\n                        throw e;\r\n                    }\r\n                    // Otherwise we failed to thumbnail, fall back to uploading an m.file\r\n                    logger.error(e);\r\n                    content.msgtype = MsgType.File;\r\n                }\r\n            } else if (file.type.startsWith(\"audio/\")) {\r\n                content.msgtype = MsgType.Audio;\r\n                try {\r\n                    const audioInfo = await infoForAudioFile(file);\r\n                    Object.assign(content.info, audioInfo);\r\n                } catch (e) {\r\n                    // Failed to process audio file, fall back to uploading an m.file\r\n                    logger.error(e);\r\n                    content.msgtype = MsgType.File;\r\n                }\r\n            } else if (file.type.startsWith(\"video/\")) {\r\n                content.msgtype = MsgType.Video;\r\n                try {\r\n                    const videoInfo = await infoForVideoFile(matrixClient, roomId, file);\r\n                    Object.assign(content.info, videoInfo);\r\n                } catch (e) {\r\n                    // Failed to thumbnail, fall back to uploading an m.file\r\n                    logger.error(e);\r\n                    content.msgtype = MsgType.File;\r\n                }\r\n            } else {\r\n                content.msgtype = MsgType.File;\r\n            }\r\n\r\n            if (upload.cancelled) throw new UploadCanceledError();\r\n            const result = await uploadFile(matrixClient, roomId, file, onProgress, upload.abortController);\r\n            content.file = result.file;\r\n            content.url = result.url;\r\n\r\n            if (upload.cancelled) throw new UploadCanceledError();\r\n            // Await previous message being sent into the room\r\n            if (promBefore) await promBefore;\r\n\r\n            if (upload.cancelled) throw new UploadCanceledError();\r\n            const threadId = relation?.rel_type === THREAD_RELATION_TYPE.name ? relation.event_id : null;\r\n\r\n            const response = await matrixClient.sendMessage(roomId, threadId ?? null, content as MediaEventContent);\r\n\r\n            if (SettingsStore.getValue(\"Performance.addSendMessageTimingMetadata\")) {\r\n                sendRoundTripMetric(matrixClient, roomId, response.event_id);\r\n            }\r\n\r\n            dis.dispatch<UploadFinishedPayload>({ action: Action.UploadFinished, upload });\r\n            dis.dispatch({ action: \"message_sent\" });\r\n        } catch (error) {\r\n            // Unwrap UploadFailedError to get the underlying error\r\n            const unwrappedError = error instanceof UploadFailedError && error.cause ? error.cause : error;\r\n\r\n            // 413: File was too big or upset the server in some way:\r\n            // clear the media size limit so we fetch it again next time we try to upload\r\n            if (unwrappedError instanceof HTTPError && unwrappedError.httpStatus === 413) {\r\n                this.mediaConfig = null;\r\n            }\r\n\r\n            if (!upload.cancelled) {\r\n                let desc = _t(\"upload_failed_generic\", { fileName: upload.fileName });\r\n                if (unwrappedError instanceof HTTPError && unwrappedError.httpStatus === 413) {\r\n                    desc = _t(\"upload_failed_size\", {\r\n                        fileName: upload.fileName,\r\n                    });\r\n                }\r\n                Modal.createDialog(ErrorDialog, {\r\n                    title: _t(\"upload_failed_title\"),\r\n                    description: desc,\r\n                });\r\n                dis.dispatch<UploadErrorPayload>({ action: Action.UploadFailed, upload, error });\r\n            }\r\n        } finally {\r\n            removeElement(this.inprogress, (e) => e.promise === upload.promise);\r\n        }\r\n    }\r\n\r\n    private isFileSizeAcceptable(file: File): boolean {\r\n        if (this.mediaConfig?.[\"m.upload.size\"] !== undefined && file.size > this.mediaConfig[\"m.upload.size\"]) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private ensureMediaConfigFetched(matrixClient: MatrixClient): Promise<void> {\r\n        if (this.mediaConfig !== null) return Promise.resolve();\r\n\r\n        logger.log(\"[Media Config] Fetching\");\r\n        return matrixClient\r\n            .getMediaConfig()\r\n            .then((config) => {\r\n                logger.log(\"[Media Config] Fetched config:\", config);\r\n                return config;\r\n            })\r\n            .catch(() => {\r\n                // Media repo can't or won't report limits, so provide an empty object (no limits).\r\n                logger.log(\"[Media Config] Could not fetch config, so not limiting uploads.\");\r\n                return {};\r\n            })\r\n            .then((config) => {\r\n                this.mediaConfig = config;\r\n            });\r\n    }\r\n\r\n    public static sharedInstance(): ContentMessages {\r\n        if (window.mxContentMessages === undefined) {\r\n            window.mxContentMessages = new ContentMessages();\r\n        }\r\n        return window.mxContentMessages;\r\n    }\r\n}\r\n","/*\nCopyright 2024 New Vector Ltd.\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nSPDX-License-Identifier: AGPL-3.0-only OR GPL-3.0-only OR LicenseRef-Element-Commercial\nPlease see LICENSE files in the repository root for full details.\n*/\n\nimport { type IContent, type MatrixClient } from \"matrix-js-sdk/src/matrix\";\n\n/**\n * Decorates the given event content object with the \"send start time\". The\n * object will be modified in-place.\n * @param {object} content The event content.\n */\nexport function decorateStartSendingTime(content: IContent): void {\n    content[\"io.element.performance_metrics\"] = {\n        sendStartTs: Date.now(),\n    };\n}\n\n/**\n * Called when an event decorated with `decorateStartSendingTime()` has been sent\n * by the server (the client now knows the event ID).\n * @param {MatrixClient} client The client to send as.\n * @param {string} inRoomId The room ID where the original event was sent.\n * @param {string} forEventId The event ID for the decorated event.\n */\nexport function sendRoundTripMetric(client: MatrixClient, inRoomId: string, forEventId: string): void {\n    // noinspection JSIgnoredPromiseFromCall\n    client.sendEvent(inRoomId, \"io.element.performance_metric\", {\n        \"io.element.performance_metrics\": {\n            forEventId: forEventId,\n            responseTs: Date.now(),\n            kind: \"send_time\",\n        },\n    });\n}\n"],"names":["crc32","module","exports","data","Error","ended","chunks","idx","length","uint8","uint32","chunk","Uint8Array","name","String","fromCharCode","push","i","crcActual","int32","buf","chunkData","buffer","slice","Int32Array","Uint32Array","factory","CRC32","version","table","c","Array","n","signed_crc_table","use_buffer","Buffer","crc32_buf_8","crc","L","bstr","charCodeAt","str","d","DO_NOT_EXPORT_CRC","RoomUpload","constructor","roomId","fileName","relation","fileSize","_defineProperty","AbortController","onProgress","progress","this","uploaded","loaded","total","abort","abortController","cancelled","signal","aborted","UploadFailureDialog","React","args","props","onFinished","render","message","buttons","totalFiles","badFiles","_t","limit","contentMessages","getUploadLimit","sizeOfThisFile","size","b","sub","DialogButtons","primaryButton","hasCancel","onPrimaryButtonClick","onCancelClick","focus","howManyOthers","count","onUploadClick","cancelButton","onCancel","BaseDialog","className","title","contentId","id","preview","PHYS_HIDPI","UploadCanceledError","UploadFailedError","cause","super","ALWAYS_INCLUDE_THUMBNAIL","async","infoForImageFile","matrixClient","imageFile","thumbnailType","type","isAnimatedPromise","blobIsAnimated","imageElement","img","Image","objectUrl","URL","createObjectURL","imgPromise","Promise","resolve","reject","onload","revokeObjectURL","onerror","e","src","parsePromise","readFileAsArrayBuffer","then","arrayBuffer","extractPngChunks","byteLength","every","val","catch","console","error","hidpi","all","width","height","loadImageElement","result","createThumbnail","imageInfo","info","undefined","includes","sizeDifference","thumbnail_info","uploadResult","uploadFile","thumbnail","url","file","infoForAudioFile","audioFile","audio","document","createElement","preload","muted","reader","FileReader","ev","_ev$target","onloadedmetadata","target","readAsDataURL","loadAudioElement","duration","Math","ceil","infoForVideoFile","videoFile","videoInfo","video","playsInline","_ev$target2","_dataUrl","onloadeddata","pause","dataUrl","startsWith","replace","load","play","loadVideoElement","videoWidth","videoHeight","Object","assign","thumbnail_url","thumbnail_file","_e$target","readAsArrayBuffer","progressHandler","controller","_matrixClient$getCryp","getCrypto","isEncryptionEnabledInRoom","encryptResult","encrypt","blob","Blob","content_uri","uploadContent","includeFilename","_objectSpread","ContentMessages","sendStickerContentToRoom","threadId","text","doMaybeLocalRoomAction","actualRoomId","sendStickerMessage","logger","warn","_this$mediaConfig$mU","_this$mediaConfig","mediaConfig","sendContentListToRoom","files","context","TimelineRenderingType","Room","isGuest","dis","dispatch","action","replyToEvent","SdkContextClass","instance","roomViewStore","getQuotingEvent","modal","Modal","createDialog","Spinner","race","ensureMediaConfigFetched","finished","close","tooBigFiles","okFiles","isFileSizeAcceptable","shouldContinue","uploadAll","promBefore","loopPromiseBefore","UploadConfirmDialog","currentIndex","shouldUploadAll","sendContentToRoom","event","Action","FocusSendMessageComposer","getCurrentUploads","inprogress","filter","roomUpload","noRelation","matchingRelation","rel_type","event_id","cancelUpload","upload","UploadCanceled","content","body","msgtype","MsgType","File","attachMentions","getSafeUserId","attachRelation","addReplyToMessageContent","SettingsStore","getValue","decorateStartSendingTime","mimetype","UploadStarted","Audio","audioInfo","Video","UploadProgress","THREAD_RELATION_TYPE","response","sendMessage","sendRoundTripMetric","UploadFinished","unwrappedError","HTTPError","httpStatus","desc","ErrorDialog","description","UploadFailed","removeElement","promise","_this$mediaConfig2","log","getMediaConfig","config","sharedInstance","window","mxContentMessages","sendStartTs","Date","now","client","inRoomId","forEventId","sendEvent","responseTs","kind"],"sourceRoot":""}